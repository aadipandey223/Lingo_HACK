# Chaos Lab â€” Comprehensive Technical Documentation

> **Complete In-Depth Technical Analysis of the Compiler Transformation Laboratory**

**Version:** 1.0.0  
**Last Updated:** February 1, 2026  
**Project Type:** Educational Compiler Research Platform

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Project Vision & Philosophy](#project-vision--philosophy)
3. [Architecture Deep Dive](#architecture-deep-dive)
4. [Compiler Pipeline](#compiler-pipeline)
5. [Transformation Engine](#transformation-engine)
6. [User Experience System](#user-experience-system)
7. [Component Architecture](#component-architecture)
8. [Validation & Quality Assurance](#validation--quality-assurance)
9. [Mode System: Student vs Researcher](#mode-system-student-vs-researcher)
10. [Technical Implementation Details](#technical-implementation-details)
11. [Testing Infrastructure](#testing-infrastructure)
12. [Performance & Optimization](#performance--optimization)
13. [Demo Flow & Use Cases](#demo-flow--use-cases)
14. [Future Roadmap](#future-roadmap)

---

## Executive Summary

**Chaos Lab** is an advanced educational platform that visualizes how compilers transform programs at the Intermediate Representation (IR) level. Unlike traditional "black box" obfuscation tools, Chaos Lab makes every transformation **visible**, **explainable**, and **verifiable** in real-time.

### Key Differentiators

- **Educational Focus**: Designed for students and researchers to understand compiler behavior
- **Real-Time Visualization**: See IR transformations happen step-by-step
- **AI-Validated Learning**: Explanations generated by AI, validated by Lingo.dev for accuracy
- **Dual-Mode Interface**: Student mode for learning, Researcher mode for experimentation
- **Semantic Preservation**: All transformations preserve program behavior
- **Budget-Controlled Chaos**: Prevents runaway complexity with configurable limits

### Technology Stack

```
Frontend:  React 18.2 + Vite 6.1
Styling:   Tailwind CSS 3.4 + Framer Motion 11.16
Testing:   Vitest 1.1 + React Testing Library
Validation: Lingo.dev Compiler Integration
Language:  JavaScript/JSX (Browser-Based)
```

---

## Project Vision & Philosophy

### The Problem

Most compiler obfuscation techniques are:
- **Opaque**: Users don't see what transformations occur
- **Unexplained**: No learning materials accompany the process
- **Unverified**: Generated explanations may contain errors
- **Inaccessible**: Require complex setup and compilation toolchains

### The Solution

Chaos Lab addresses these issues by:

1. **Transparency**: Every transformation is shown in a visual timeline
2. **Education**: AI-generated explanations for each technique
3. **Validation**: Lingo.dev acts as a "truth gate" to verify explanations
4. **Accessibility**: Runs entirely in the browser with zero setup

### Core Principles

#### 1. **Semantic Preservation**
All transformations guarantee that output behavior matches input behavior. The compiler verifies this by executing both original and transformed IR and comparing results.

#### 2. **Explainability Over Complexity**
Rather than maximizing obfuscation, Chaos Lab prioritizes educational value and understandability of each transformation step.

#### 3. **Trust Through Verification**
AI explanations (MCP layer) are treated as untrusted until validated by Lingo.dev's rule-based authority.

#### 4. **Progressive Disclosure**
Student mode hides complexity; Researcher mode exposes full control. Users learn fundamentals before advanced experimentation.

---

## Architecture Deep Dive

### System Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     USER INTERFACE LAYER                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Editor   â”‚  â”‚ Timeline â”‚  â”‚ Summary  â”‚  â”‚ Explanation â”‚ â”‚
â”‚  â”‚ Panel    â”‚  â”‚ View     â”‚  â”‚ Panel    â”‚  â”‚ Panel       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  COMPILATION ORCHESTRATOR                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  handleCompile() - Main Entry Point                  â”‚  â”‚
â”‚  â”‚  â€¢ Manages state                                     â”‚  â”‚
â”‚  â”‚  â€¢ Coordinates pipeline                              â”‚  â”‚
â”‚  â”‚  â€¢ Captures snapshots                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    COMPILER PIPELINE                         â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Lexer   â”‚  â†’   â”‚  Parser  â”‚  â†’   â”‚ IR Generator â”‚     â”‚
â”‚  â”‚          â”‚      â”‚          â”‚      â”‚              â”‚     â”‚
â”‚  â”‚ Tokens   â”‚      â”‚   AST    â”‚      â”‚  IR Stream   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                              â”‚              â”‚
â”‚                                              â–¼              â”‚
â”‚                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚                                     â”‚ Chaos Engine â”‚       â”‚
â”‚                                     â”‚   (4 Passes) â”‚       â”‚
â”‚                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                              â”‚              â”‚
â”‚                                              â–¼              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ IR Executor â”‚  â†  Verification  â”‚   CodeGen    â”‚       â”‚
â”‚  â”‚  (Original  â”‚                   â”‚  (Assembly)  â”‚       â”‚
â”‚  â”‚ & Chaotic)  â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              VALIDATION & DIAGNOSTIC LAYER                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  MCP (Untrusted)        â†’      Lingo.dev (Authority) â”‚  â”‚
â”‚  â”‚  AI Explanations               Schema Validation      â”‚  â”‚
â”‚  â”‚  Generated Content             Glossary Enforcement   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

```javascript
// 1. User Input
const sourceCode = `int main() { return 10 + 20; }`;

// 2. Lexical Analysis
const tokens = lexer.tokenize(sourceCode);
// â†’ [INT, MAIN, LPAREN, RPAREN, LBRACE, RETURN, NUMBER, ...]

// 3. Syntax Analysis
const ast = parser.parse(tokens);
// â†’ { type: 'Program', body: [FunctionDeclaration, ...] }

// 4. IR Generation
const ir = generateIR(ast);
// â†’ [{ op: 'ADD', target: 't0', left: 10, right: 20 }, ...]

// 5. Transformation
const { ir: chaoticIR, snapshots, ruleHits } = applyChaos(ir, 'medium', config);
// â†’ Transformed IR + Step-by-step snapshots

// 6. Execution & Verification
const originalResult = executeIR(originalIR);    // 30
const transformedResult = executeIR(chaoticIR);  // 30
assert(originalResult === transformedResult);     // âœ“

// 7. Diagnostics Generation
diagnostics.emit('CHAOS_NUM_ENCODING', 'chaos.data.encoding', 'info', {...});

// 8. Validation
const validated = LingoCompiler.validate(diagnostics.getDiagnostics());
// â†’ { valid: true, errors: [], warnings: [] }
```

---

## Compiler Pipeline

### 1. Lexical Analysis (Lexer)

**File:** `src/compiler/lexer.js`

The lexer converts source code into a stream of tokens.

**Supported Token Types:**
```javascript
TokenType = {
    // Keywords
    INT, RETURN, MAIN, IF, ELSE, WHILE, FOR, SIZEOF,
    DOUBLE, CONST,
    
    // Identifiers & Literals
    IDENTIFIER, NUMBER, STRING,
    
    // Operators
    ASSIGN, PLUS, MINUS, STAR, SLASH, LESS, GREATER, BANG,
    
    // Delimiters
    LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET,
    SEMICOLON, COMMA,
    
    // Special
    EOF
}
```

**Example:**
```c
int a = 10;
```
**Tokens:**
```javascript
[
  { type: 'INT', value: 'int', line: 1 },
  { type: 'IDENTIFIER', value: 'a', line: 1 },
  { type: 'ASSIGN', value: '=', line: 1 },
  { type: 'NUMBER', value: '10', line: 1 },
  { type: 'SEMICOLON', value: ';', line: 1 }
]
```

**Features:**
- Single-line comment support (`//`)
- String literals with escape sequences
- Decimal number support
- Line number tracking for error reporting

### 2. Syntax Analysis (Parser)

**File:** `src/compiler/parser.js`

The parser builds an Abstract Syntax Tree (AST) from tokens.

**AST Node Types:**
```javascript
- Program
- FunctionDeclaration
- VariableDeclaration
- AssignmentStatement
- ReturnStatement
- IfStatement
- WhileStatement
- ForStatement
- BlockStatement
- BinaryExpression
- CallExpression
- Identifier
- Literal
```

**Example:**
```c
int main() {
  int result = 5 + 3;
  return result;
}
```

**AST:**
```javascript
{
  type: 'Program',
  body: [{
    type: 'FunctionDeclaration',
    name: 'main',
    params: [],
    body: [
      {
        type: 'VariableDeclaration',
        kind: 'int',
        declarations: [{
          id: 'result',
          init: {
            type: 'BinaryExpression',
            operator: '+',
            left: { type: 'Literal', value: 5 },
            right: { type: 'Literal', value: 3 }
          }
        }]
      },
      {
        type: 'ReturnStatement',
        argument: { type: 'Identifier', name: 'result' }
      }
    ]
  }]
}
```

### 3. IR Generation

**File:** `src/compiler/ir.js`

Converts AST to three-address code intermediate representation.

**IR Instruction Format:**
```javascript
{
  op: 'ADD',           // Operation type
  target: 't0',        // Result destination
  left: 5,             // First operand
  right: 3,            // Second operand
  meta: 'USER_CODE'    // Metadata tag
}
```

**Supported Operations:**
- Arithmetic: `ADD`, `SUB`, `MUL`, `DIV`
- Logic: `AND`, `OR`, `XOR`, `NOT`
- Comparison: `LESS`, `GREATER`
- Memory: `ASSIGN`, `LOAD`, `STORE`
- Control: `IF`, `WHILE`, `RETURN`, `CALL`

**Example IR:**
```javascript
[
  { op: 'ADD', target: 't0', left: 5, right: 3 },
  { op: 'ASSIGN', target: 'result', value: 't0' },
  { op: 'RETURN', value: 'result' }
]
```

### 4. Code Generation

**File:** `src/compiler/codegen.js`

Generates pseudo-assembly from AST (parallel to IR execution).

**Output Format:**
```assembly
main:
    ; Variable: result
    mov eax, 5
    add eax, 3
    mov [result], eax
    mov eax, [result]
    ret
```

---

## Transformation Engine

### Chaos Engine Overview

The chaos engine applies **four transformation passes** to IR code:

1. **Number Encoding** - Obfuscates integer constants
2. **Instruction Substitution** - Replaces operations with equivalent sequences
3. **Opaque Predicates** - Injects always-true conditions
4. **Control Flow Flattening** - Restructures execution paths

### Budget System

To prevent runaway complexity, Chaos Lab enforces resource limits:

```javascript
const CHAOS_LIMITS = {
    maxNewInstructions: 30,  // Max additional IR instructions
    maxControlDepth: 3,       // Max nested control structures
    maxEncodingOps: 10        // Max number encoding operations
};
```

**Budget Tracking:**
```javascript
let budget = {
    instructionsAdded: 0,
    controlDepth: 0,
    encodingOps: 0
};

const checkBudget = (type, cost) => {
    if (budget[type] + cost > CHAOS_LIMITS[type]) {
        diagnostics.emit('CHAOS_BUDGET_EXHAUSTED', ...);
        return false;
    }
    budget[type] += cost;
    return true;
};
```

### Seeded Random Number Generator

For **deterministic transformations** (essential for testing):

```javascript
let currentSeed = 1;

const seededRandom = () => {
    currentSeed = (currentSeed * 16807) % 2147483647;
    return (currentSeed - 1) / 2147483646;
};

const setSeed = (seed) => {
    currentSeed = seed % 2147483647;
    if (currentSeed <= 0) currentSeed += 2147483646;
};
```

**Usage:**
```javascript
// Same seed â†’ Same transformations
applyChaos(ir, 'medium', 12345); // Deterministic
applyChaos(ir, 'medium', 12345); // Identical result
```

### Transformation Pass 1: Number Encoding

**Purpose:** Replace integer constants with algebraic expressions to hide original values.

**Algorithm:**
```javascript
// Original: x = 5
// Transformed: t1 = 5 + 7, x = t1 - 7

if (instr.op === 'ASSIGN' && typeof instr.value === 'number') {
    const offset = randomInt(1, 10);
    const temp = generateTemp();
    
    emit({ op: 'ADD', target: temp, left: value, right: offset });
    emit({ op: 'SUB', target: instr.target, left: temp, right: offset });
    
    budget.encodingOps += 1;
    budget.instructionsAdded += 2;
}
```

**Example:**
```
Before:  [{ op: 'ASSIGN', target: 'a', value: 10 }]

After:   [
           { op: 'ADD', target: 'enc_add_0', left: 10, right: 7 },
           { op: 'SUB', target: 'a', left: 'enc_add_0', right: 7 }
         ]

Preserved: a = 10 âœ“
```

### Transformation Pass 2: Instruction Substitution

**Purpose:** Replace arithmetic operations with bitwise equivalents to obscure logic.

**Mathematical Identity:**
```
a + b = (a ^ b) + 2 * (a & b)

Where:
  a ^ b  = XOR (adds without carry)
  a & b  = AND (isolates carry bits)
  2 * (a & b) = Adds carry back
```

**Algorithm:**
```javascript
if (instr.op === 'ADD') {
    const t1 = genTemp();  // XOR result
    const t2 = genTemp();  // AND result
    const t3 = genTemp();  // Doubled carry
    
    emit({ op: 'XOR', target: t1, left: instr.left, right: instr.right });
    emit({ op: 'AND', target: t2, left: instr.left, right: instr.right });
    emit({ op: 'MUL', target: t3, left: t2, right: 2 });
    emit({ op: 'ADD', target: instr.target, left: t1, right: t3 });
    
    budget.instructionsAdded += 4;
}
```

**Example:**
```
Before:  [{ op: 'ADD', target: 't0', left: 5, right: 3 }]

After:   [
           { op: 'XOR', target: 'xor_0', left: 5, right: 3 },    // 6
           { op: 'AND', target: 'and_0', left: 5, right: 3 },    // 1
           { op: 'MUL', target: 'mul_0', left: 'and_0', right: 2 }, // 2
           { op: 'ADD', target: 't0', left: 'xor_0', right: 'mul_0' } // 8
         ]

Verification: 5 + 3 = 8 âœ“
```

### Transformation Pass 3: Opaque Predicates

**Purpose:** Insert conditions that always evaluate to true but are hard to analyze statically.

**Mathematical Invariant:**
```
(x * x + x) % 2 == 0  (always true for integers)

Proof:
  xÂ² + x = x(x + 1)
  Either x or x+1 is even
  Therefore product is always even
```

**Algorithm:**
```javascript
if (shouldInjectOpaquePredicate(probability)) {
    const var = selectRandomVariable();
    const temp1 = genTemp();
    const temp2 = genTemp();
    const temp3 = genTemp();
    
    emit({ op: 'MUL', target: temp1, left: var, right: var });
    emit({ op: 'ADD', target: temp2, left: temp1, right: var });
    emit({ op: 'MOD', target: temp3, left: temp2, right: 2 });
    emit({ op: 'IF', test: { op: 'EQ', left: temp3, right: 0 }, 
           consequent: actualCode, 
           alternate: [] });
    
    budget.controlDepth += 1;
}
```

**Example:**
```
Before:  [{ op: 'ASSIGN', target: 'result', value: 't0' }]

After:   [
           { op: 'MUL', target: 'op_1', left: 'x', right: 'x' },
           { op: 'ADD', target: 'op_2', left: 'op_1', right: 'x' },
           { op: 'MOD', target: 'op_3', left: 'op_2', right: 2 },
           { op: 'IF', test: { ... eq 0 }, 
             consequent: [{ op: 'ASSIGN', target: 'result', value: 't0' }],
             alternate: []
           }
         ]

Runtime: Always takes consequent branch âœ“
```

### Transformation Pass 4: Control Flow Flattening

**Purpose:** Convert linear code into dispatcher-based execution to hide execution order.

**Pattern:**
```
Linear:                  Flattened:
  stmt1;                 int state = 0;
  stmt2;                 while(true) {
  stmt3;                   switch(state) {
                             case 0: stmt1; state=1; break;
                             case 1: stmt2; state=2; break;
                             case 2: stmt3; return;
                           }
                         }
```

**Algorithm:**
```javascript
const flattenBlock = (block) => {
    const stateVar = genTemp();
    const cases = [];
    
    block.forEach((stmt, idx) => {
        cases.push({
            caseValue: idx,
            body: [...stmt, { op: 'ASSIGN', target: stateVar, value: idx + 1 }]
        });
    });
    
    return {
        op: 'WHILE',
        test: { type: 'Literal', value: true },
        body: { op: 'SWITCH', discriminant: stateVar, cases }
    };
};
```

### Custom Mutation Rules

**Researcher Mode Feature:** Define custom substitution patterns.

**Format:**
```javascript
{
    source: 'ADD',                      // Original operation
    target: 'XOR, AND, MUL, ADD',       // Replacement sequence
    id: 123456                          // Unique identifier
}
```

**Processing:**
```javascript
const applyCustomRule = (instr, rule) => {
    if (instr.op === rule.source) {
        const ops = rule.target.split(',').map(s => s.trim());
        let lastResult = instr.left;
        
        ops.forEach((op, idx) => {
            const temp = genTemp();
            emit({ op, target: temp, left: lastResult, right: instr.right });
            lastResult = temp;
        });
        
        emit({ op: 'ASSIGN', target: instr.target, value: lastResult });
        ruleHits[rule.id] = (ruleHits[rule.id] || 0) + 1;
    }
};
```

---

## User Experience System

### Mode System: Student vs Researcher

Chaos Lab provides **two distinct experiences** based on user expertise:

#### Student Mode (ğŸ“ Default)

**Purpose:** Learn compiler fundamentals without overwhelming complexity.

**Features:**
- âœ… Example library (4 categories)
- âœ… Learning narrative panel
- âœ… Simplified terminology
- âœ… Transformation timeline view
- âœ… AI-explained transformations
- âœ… Basic pass toggles
- âŒ Custom mutation rules
- âŒ Rule priority controls
- âŒ Advanced orchestration

**Terminology Simplification:**
```javascript
const STUDENT_TERMS = {
    'opaquePredicates': 'Hidden Conditions',
    'flattening': 'Execution Restructuring',
    'substitution': 'Instruction Substitution',
    'numberEncoding': 'Number Encoding'
};
```

#### Researcher Mode (ğŸ”¬ Advanced)

**Purpose:** Experiment with custom transformations and study edge cases.

**Features:**
- âœ… All Student features
- âœ… Custom rule editor
- âœ… Drag-and-drop rule priority
- âœ… Full orchestration panel
- âœ… Preset save/load system
- âœ… Rule hit tracking
- âœ… Technical terminology

**Custom Rule Interface:**
```jsx
<ChaosConfig
    config={chaosConfig}
    setConfig={setChaosConfig}
    ruleHits={ruleHits}
    mode="researcher"
/>
```

### Tab Architecture

**Final Tab Structure:**

1. **Editor** - Code entry and compilation controls
2. **Transformation Timeline** - Step-by-step IR changes
3. **Transformations & Explanations** - Detailed pass breakdown
4. **Chaos Orchestration** - (Researcher only) Advanced controls
5. **Pipeline Components** - System architecture view

### Example Library

**4 Categorized Examples:**

```javascript
const EXAMPLE_CATEGORIES = {
    arithmetic: {
        label: 'Arithmetic',
        icon: 'ğŸ”¢',
        code: 'int main() { int a = 10; int b = 20; return a + b; }',
        desc: 'Basic math operations'
    },
    loops: {
        label: 'Loops',
        icon: 'ğŸ”„',
        code: 'int main() { int sum = 0; int i = 1; while (i <= 5) { sum += i; i++; } return sum; }',
        desc: 'Iteration and accumulation'
    },
    branching: {
        label: 'Branching',
        icon: 'ğŸ”€',
        code: 'int main() { int x = 15; return (x > 10) ? x * 2 : x + 5; }',
        desc: 'Conditional logic'
    },
    obfuscation: {
        label: 'Obfuscation Demo',
        icon: 'ğŸ”’',
        code: 'int main() { int a = 5; int b = 3; int c = (a + b) * 2; return c - a; }',
        desc: 'Complex transformations'
    }
};
```

### Learning Narrative Panel

**Visual Pipeline Stages:**

```jsx
const stages = [
    { id: 1, label: 'Code Parsed', icon: Code },
    { id: 2, label: 'IR Generated', icon: Grid3x3 },
    { id: 3, label: 'Transformations Applied', icon: Zap },
    { id: 4, label: 'Code Emitted', icon: FileCode }
];
```

**State Tracking:**
- âšª Not started (gray)
- âœ… Complete (green with checkmark)

### Transformation Summary

**Post-Compilation Display:**

```jsx
<TransformationSummary 
    appliedPasses={['numberEncoding', 'substitution']}
    chaosConfig={config}
    mode="student"
/>
```

**Output:**
```
Transformations Applied:
âœ“ Number Encoding
âœ“ Instruction Substitution
â—‹ Hidden Conditions
â—‹ Execution Restructuring

+ 2 custom mutation rules
```

---

## Component Architecture

### React Component Hierarchy

```
App.jsx (Root)
â”œâ”€â”€ IntroOverlay.jsx (First-run experience)
â”œâ”€â”€ Navigation Bar
â”‚   â”œâ”€â”€ Mode Toggle (Student/Researcher)
â”‚   â”œâ”€â”€ Tab Selector
â”‚   â””â”€â”€ Lingo Status Badge
â”œâ”€â”€ ExampleLibrary.jsx (4 category buttons)
â”œâ”€â”€ LearningNarrative.jsx (4-step pipeline)
â”œâ”€â”€ EditorPanel.jsx
â”‚   â”œâ”€â”€ Monaco-style editor
â”‚   â”œâ”€â”€ Intensity selector
â”‚   â”œâ”€â”€ Compile button
â”‚   â””â”€â”€ Quick start banner (guided tour)
â”œâ”€â”€ IRDiffView.jsx
â”‚   â””â”€â”€ Snapshot carousel with diff highlighting
â”œâ”€â”€ TransformationSummary.jsx
â”‚   â””â”€â”€ Applied passes checklist
â”œâ”€â”€ LingoPanel.jsx
â”‚   â”œâ”€â”€ DiagnosticsViewer.jsx
â”‚   â”œâ”€â”€ Mode selector (Student/Researcher)
â”‚   â””â”€â”€ Failure simulation controls
â”œâ”€â”€ ChaosConfig.jsx (Researcher mode)
â”‚   â”œâ”€â”€ Pass toggles
â”‚   â”œâ”€â”€ Custom rule editor
â”‚   â”œâ”€â”€ Drag-drop priority
â”‚   â”œâ”€â”€ Preset save/load
â”‚   â””â”€â”€ Rule hit counter
â”œâ”€â”€ PipelineTab.jsx (Architecture visualization)
â””â”€â”€ Guided Tour Overlay (3-step walkthrough)
```

### State Management

**App-Level State:**
```javascript
const [mode, setMode] = useState('student');           // UI mode
const [activeTab, setActiveTab] = useState('editor');  // Current tab
const [code, setCode] = useState(EXAMPLES[0]);         // Source code
const [intensity, setIntensity] = useState('medium');  // Chaos level
const [isCompiled, setIsCompiled] = useState(false);   // Compilation status

// Compilation Results
const [ast, setAst] = useState(null);
const [originalIr, setOriginalIr] = useState([]);
const [chaoticIr, setChaoticIr] = useState([]);
const [irSnapshots, setIrSnapshots] = useState([]);
const [assembly, setAssembly] = useState('');
const [executionOutput, setExecutionOutput] = useState(null);

// Chaos Configuration
const [chaosConfig, setChaosConfig] = useState({
    passes: { numberEncoding: true, substitution: true, ... },
    customRules: []
});
const [ruleHits, setRuleHits] = useState({});
const [appliedPasses, setAppliedPasses] = useState([]);

// Validation
const [compilerDiagnostics, setCompilerDiagnostics] = useState([]);
const [lingoReport, setLingoReport] = useState({ valid: true, ... });

// Tour
const [showGuidedTour, setShowGuidedTour] = useState(false);
const [guidedTourStep, setGuidedTourStep] = useState(0);
```

### Key Components Deep Dive

#### EditorPanel.jsx

**Purpose:** Code input and compilation controls.

**Features:**
- Syntax-highlighted editor (Prism.js)
- Line numbers
- Beautify function
- Example loader
- Intensity selector (Low/Medium/High)
- Compile button with loading state
- Lingo validation badge

**Props:**
```javascript
{
    code: string,
    setCode: (code) => void,
    intensity: 'low' | 'medium' | 'high',
    setIntensity: (level) => void,
    onCompile: () => void,
    onFormat: () => void,
    onLoadExample: () => void,
    isCompiling: boolean,
    lingoValid: boolean | undefined,
    showQuickWin: boolean  // Guided tour flag
}
```

#### IRDiffView.jsx

**Purpose:** Visualize transformation snapshots.

**Features:**
- Carousel navigation through passes
- Side-by-side diff view
- Syntax highlighting for IR
- Added/removed instruction highlighting
- Pass name labels

**Data Structure:**
```javascript
snapshots = [
    { name: 'Original', ir: [...] },
    { name: 'Number Encoding', ir: [...] },
    { name: 'Substitution', ir: [...] },
    { name: 'Opaque Predicates', ir: [...] },
    { name: 'Flattening', ir: [...] }
];
```

#### LingoPanel.jsx

**Purpose:** Display validated explanations.

**Features:**
- Diagnostic list with severity badges
- Explanation mode toggle (Student/Researcher)
- Failure simulation dropdown
- Validation status overview
- Side-by-side JSON/error preview (failure mode)

**Validation Flow:**
```javascript
// 1. Generate diagnostics
diagnostics.emit('CHAOS_NUM_ENCODING', 'chaos.data', 'info', { orig: 5, enc: 't1' });

// 2. Inject test failure (optional)
const testDiags = LingoCompiler.injectTestFailure(diags, 'MISSING_SEVERITY');

// 3. Validate
const report = LingoCompiler.generateReport(testDiags);

// 4. Render based on validity
if (report.valid) {
    return <DiagnosticsViewer diagnostics={diags} />;
} else {
    return <ValidationErrorView report={report} />;
}
```

#### ChaosConfig.jsx

**Purpose:** (Researcher mode) Advanced transformation control.

**Features:**
- Pass enable/disable toggles
- Custom rule editor
- Drag-and-drop rule reordering
- Rule hit counter display
- Demo preset shortcuts
- Save/load preset system
- Reset to defaults

**Custom Rule Editor:**
```jsx
<div className="rule-editor">
    <input 
        placeholder="Source operation (e.g., ADD)"
        value={newRule.source}
        onChange={e => setNewRule({...newRule, source: e.target.value})}
    />
    <input 
        placeholder="Target sequence (e.g., XOR, AND, MUL)"
        value={newRule.target}
        onChange={e => setNewRule({...newRule, target: e.target.value})}
    />
    <button onClick={addRule}>Add Rule</button>
</div>

<DragDropContext onDragEnd={handleDragEnd}>
    <Droppable droppableId="rules">
        {customRules.map((rule, idx) => (
            <Draggable key={rule.id} draggableId={String(rule.id)} index={idx}>
                <RuleCard rule={rule} hits={ruleHits[rule.id] || 0} />
            </Draggable>
        ))}
    </Droppable>
</DragDropContext>
```

---

## Validation & Quality Assurance

### Lingo.dev Integration

**Purpose:** Act as "truth gate" for AI-generated content.

**Validation Levels:**

#### 1. Schema Validation (Structural)
```javascript
const REQUIRED_FIELDS = ['id', 'context', 'severity'];

diagnostics.forEach(d => {
    REQUIRED_FIELDS.forEach(field => {
        if (!d[field]) {
            errors.push(`Missing required field '${field}'`);
        }
    });
});
```

#### 2. Vocabulary Enforcement (Semantic)
```javascript
const GLOSSARY = [
    'block', 'ir', 'ssa', 'chaos', 'predicate', 'operator',
    'instruction', 'transformation', 'strategy', 'intensity',
    'original', 'value', 'budget', 'safety', 'seed'
];

if (d.params) {
    Object.keys(d.params).forEach(key => {
        if (!GLOSSARY.includes(key.toLowerCase())) {
            warnings.push(`Non-standard term: '${key}'`);
        }
    });
}
```

#### 3. ID Prefix Validation
```javascript
const VALID_ID_PREFIXES = ['CHAOS_', 'LINGO_', 'IR_', 'PARSE_', 'CODEGEN_'];

if (!VALID_ID_PREFIXES.some(prefix => d.id.startsWith(prefix))) {
    warnings.push(`Invalid ID prefix: '${d.id}'`);
}
```

#### 4. Explanation Drift Detection
```javascript
// Ensure explanation references actual parameter values
if (d.explanation && d.params) {
    const cleanText = d.explanation.toLowerCase();
    Object.entries(d.params).forEach(([key, value]) => {
        if (!cleanText.includes(String(value).toLowerCase())) {
            warnings.push(`Explanation missing reference to ${key}=${value}`);
        }
    });
}
```

### Test Failure Simulation

**Purpose:** Demonstrate Lingo's authority by intentionally violating rules.

**Modes:**
```javascript
const TEST_FAILURE_MODES = {
    'MISSING_SEVERITY': {
        id: 'LINGO_TEST_001',
        context: 'Missing severity field',
        // severity: intentionally omitted
    },
    'EMPTY_CONTEXT': {
        id: 'LINGO_TEST_002',
        context: '',  // Intentionally empty
        severity: 'medium'
    },
    'INVALID_ID_FORMAT': {
        id: 'bad_id_123',  // No valid prefix
        context: 'Invalid ID format',
        severity: 'low'
    },
    'UNKNOWN_TERM': {
        id: 'LINGO_TEST_003',
        context: 'Uses non-glossary term',
        params: { magic_spells: true },  // Not in glossary
        severity: 'high'
    }
};
```

**UI Flow:**
```jsx
<select onChange={e => setSimulateError(e.target.value)}>
    <option value="">No Simulation</option>
    <option value="MISSING_SEVERITY">Missing Severity</option>
    <option value="EMPTY_CONTEXT">Empty Context</option>
    <option value="INVALID_ID_FORMAT">Invalid ID Format</option>
    <option value="UNKNOWN_TERM">Unknown Term</option>
</select>

{simulateError && (
    <div className="validation-failure-preview">
        <h4>Injected JSON:</h4>
        <pre>{JSON.stringify(TEST_FAILURE_MODES[simulateError], null, 2)}</pre>
        
        <h4>Lingo Validation Errors:</h4>
        <ul>
            {lingoReport.errors.map(err => <li>{err}</li>)}
        </ul>
    </div>
)}
```

### Semantic Preservation Verification

**Critical Feature:** Ensures transformations don't change program behavior.

**Algorithm:**
```javascript
const handleCompile = () => {
    // 1. Generate IR from AST
    const ir = generateIR(ast);
    
    // 2. Execute original IR
    const originalResult = executeIR(JSON.parse(JSON.stringify(ir)));
    
    // 3. Apply transformations
    const { ir: transformedIR } = applyChaos(ir, intensity, seed, config);
    
    // 4. Execute transformed IR
    const transformedResult = executeIR(transformedIR);
    
    // 5. Compare results
    if (originalResult !== transformedResult) {
        throw new Error(
            `Semantic mismatch! Original: ${originalResult}, ` +
            `Transformed: ${transformedResult}`
        );
    }
    
    // 6. Display verification badge
    setSemanticCheckPassed(originalResult === transformedResult);
};
```

**UI Indicator:**
```jsx
<div className="semantic-check">
    {executionOutput === originalOutput ? (
        <>
            <CheckCircle className="text-emerald-500" />
            <span>Semantic Check: Passed</span>
        </>
    ) : (
        <>
            <XCircle className="text-red-500" />
            <span>Semantic Check: Failed (Mismatch Rejected)</span>
        </>
    )}
    <span className="original-value">orig: {originalOutput}</span>
</div>
```

---

## Testing Infrastructure

### Test Suite Overview

**Framework:** Vitest 1.1 + React Testing Library

**Coverage:**
- âœ… 33 tests across 4 suites
- âœ… 100% pass rate
- âœ… Deterministic transformations
- âœ… Validation scenarios

### Test Suites

#### 1. Lexer Tests (`lexer.test.js`)

**6 tests covering:**
- Integer variable declarations
- Arithmetic operations tokenization
- Multiple operators in sequence
- Function declaration structure
- Whitespace and newline handling
- Negative number recognition

**Example:**
```javascript
it('should tokenize integer declarations', () => {
    const lexer = new Lexer('int x = 42;');
    const tokens = lexer.tokenize();
    
    expect(tokens[0].type).toBe(TokenType.INT);
    expect(tokens[1].type).toBe(TokenType.IDENTIFIER);
    expect(tokens[2].type).toBe(TokenType.ASSIGN);
    expect(tokens[3].type).toBe(TokenType.NUMBER);
    expect(tokens[3].value).toBe('42');
});
```

#### 2. Parser Tests (`parser.test.js`)

**6 tests covering:**
- Variable declaration AST structure
- Function with return statement
- Binary expression parsing
- Operator precedence handling
- Empty function bodies
- Multiple statement sequences

**Example:**
```javascript
it('should parse binary expressions with precedence', () => {
    const code = 'int x = 2 + 3 * 4;';
    const lexer = new Lexer(code);
    const parser = new Parser(lexer.tokenize());
    const ast = parser.parse();
    
    const expr = ast.body[0].declarations[0].init;
    expect(expr.type).toBe('BinaryExpression');
    expect(expr.operator).toBe('+');
    expect(expr.right.operator).toBe('*');  // Higher precedence
});
```

#### 3. IR & Chaos Engine Tests (`ir.test.js`)

**11 tests covering:**
- IR generation from AST
- Deterministic transformations (seeded RNG)
- Snapshot generation at each pass
- Budget limit enforcement
- Semantic preservation
- Intensity level scaling
- IR execution correctness
- Custom rule application
- Pass enable/disable

**Example:**
```javascript
it('should generate deterministic transformations with same seed', () => {
    const ir = [{ op: 'ADD', target: 't0', left: 5, right: 3 }];
    const seed = 12345;
    
    const result1 = applyChaos(ir, 'medium', seed);
    const result2 = applyChaos(ir, 'medium', seed);
    
    expect(JSON.stringify(result1.ir)).toBe(JSON.stringify(result2.ir));
    expect(result1.snapshots.length).toBe(result2.snapshots.length);
});

it('should preserve semantics after transformations', () => {
    const ast = parser.parse(lexer.tokenize('int main() { return 10 + 20; }'));
    const ir = generateIR(ast);
    
    const originalResult = executeIR(ir);
    const { ir: transformedIR } = applyChaos(ir, 'high');
    const transformedResult = executeIR(transformedIR);
    
    expect(transformedResult).toBe(originalResult);
    expect(transformedResult).toBe(30);
});

it('should warn when budget is exhausted', () => {
    const largeIR = Array(50).fill().map((_, i) => ({
        op: 'ASSIGN', target: `var${i}`, value: i
    }));
    
    diagnostics.clear();
    applyChaos(largeIR, 'high');
    
    const diags = diagnostics.getDiagnostics();
    const budgetWarning = diags.find(d => d.id === 'CHAOS_BUDGET_EXHAUSTED');
    expect(budgetWarning).toBeDefined();
});
```

#### 4. Lingo Validation Tests (`lingo.test.js`)

**10 tests covering:**
- Schema validation (required fields)
- Missing field detection
- Invalid severity values
- ID prefix conventions
- Empty context string detection
- Non-glossary parameter warnings
- Report generation structure
- Test failure mode injection
- Valid diagnostic acceptance
- Warning vs error distinction

**Example:**
```javascript
it('should detect missing required fields', () => {
    const invalidDiag = {
        id: 'TEST_001',
        // missing: context, severity
    };
    
    const report = LingoCompiler.generateReport([invalidDiag]);
    
    expect(report.valid).toBe(false);
    expect(report.errors.length).toBeGreaterThan(0);
    expect(report.errors[0]).toContain('context');
});

it('should validate glossary terms', () => {
    const diagWithUnknownTerm = {
        id: 'CHAOS_TEST',
        context: 'Test diagnostic',
        severity: 'info',
        params: { mystical_energy: 9000 }  // Not in glossary
    };
    
    const report = LingoCompiler.generateReport([diagWithUnknownTerm]);
    
    expect(report.warnings.length).toBeGreaterThan(0);
    expect(report.warnings[0]).toContain('mystical_energy');
});

it('should accept valid diagnostics', () => {
    const validDiag = {
        id: 'CHAOS_NUM_ENCODING',
        context: 'chaos.data.encoding',
        severity: 'info',
        params: { original: 5, encoding: 't1' }
    };
    
    const report = LingoCompiler.generateReport([validDiag]);
    
    expect(report.valid).toBe(true);
    expect(report.errors.length).toBe(0);
});
```

### Running Tests

```bash
# Run all tests once
npm test

# Watch mode (auto-rerun on changes)
npm run test:watch

# Interactive UI
npm run test:ui

# Coverage report
npm run test:coverage
```

### Test Configuration

**File:** `vitest.config.js`

```javascript
import { defineConfig } from 'vitest/config';

export default defineConfig({
    test: {
        globals: true,
        environment: 'jsdom',
        setupFiles: './src/test/setup.js',
        coverage: {
            provider: 'v8',
            reporter: ['text', 'json', 'html'],
            exclude: [
                'node_modules/',
                'src/test/',
                '**/*.config.js'
            ]
        }
    }
});
```

---

## Performance & Optimization

### Build Optimization

**Bundle Size:**
```
dist/index.html          0.56 kB  (gzip: 0.37 kB)
dist/assets/index.css   52.74 kB  (gzip: 9.42 kB)
dist/assets/index.js   702.47 kB  (gzip: 201.53 kB)

Build time: 4.78s
```

**Optimization Strategies:**

1. **Code Splitting** (Recommended for future)
```javascript
// Dynamic imports for heavy components
const PipelineTab = lazy(() => import('./components/PipelineTab'));
const ChaosConfig = lazy(() => import('./components/ChaosConfig'));
```

2. **Tree Shaking**
- Vite automatically removes unused Radix UI components
- Lucide icons imported individually

3. **Production Build**
```bash
npm run build
# Minification, dead code elimination, compression
```

### Runtime Performance

**IR Execution Complexity:**
```
Time Complexity: O(n) where n = IR instruction count
Space Complexity: O(v + t) where v = variables, t = temps

Typical execution:
  - 50 instructions: < 1ms
  - 200 instructions (heavy chaos): < 5ms
```

**Transformation Performance:**
```javascript
// Budget limits prevent exponential growth
applyChaos(ir, 'high');
// Max 30 new instructions added
// Max 3 control depth
// Guaranteed termination
```

### Memory Management

**Snapshot Storage:**
```javascript
// Each snapshot stores IR copy
const snapshots = [
    { name: 'Original', ir: deepCopy(ir) },
    { name: 'Pass1', ir: deepCopy(transformedIR) },
    ...
];

// Typical memory usage:
// 5 snapshots Ã— 100 instructions Ã— 100 bytes â‰ˆ 50KB
```

**State Cleanup:**
```javascript
const handleCompile = () => {
    // Clear previous state
    setIrSnapshots([]);
    setRuleHits({});
    diagnostics.clear();
    
    // Compile...
};
```

---

## Demo Flow & Use Cases

### Guided Tour (First-Run Experience)

**3-Step Walkthrough:**

**Step 1: Preset Loaded**
```
ğŸ¯ Position: Top center
ğŸ“ Message: "âœ“ Heavy Obfuscation Loaded
           All transformation passes enabled.
           Click 'Run Lab Engine' to see code transform!"
ğŸ¬ Action: Auto-loads Heavy Obfuscation preset
```

**Step 2: Compilation Complete**
```
ğŸ¯ Position: Right side
ğŸ“ Message: "âœ“ Code Transformed!
           Check the IR Diff panel â†’
           Each stage shows what changed."
ğŸ¬ Trigger: After successful compilation
ğŸ”„ Auto-advance: After user clicks "Next"
```

**Step 3: Diagnostics**
```
ğŸ¯ Position: Bottom center
ğŸ“ Message: "Scroll down to see Diagnostics
           AI-generated explanations validated by Lingo.
           Try the failure simulation!"
ğŸ¬ Action: Points to LingoPanel
âœ… Complete: Click "Finish tour"
```

### Demo Script (2-Minute Pitch)

**Minute 1: Problem & Solution**
```
Script:
"Most compiler tools are black boxes. You don't see what's happening inside.

Chaos Lab makes transformations visible and explainable.

[Click Arithmetic example]

This is simple addition. Watch what happens when we apply compiler transformations."

[Click "Run Lab Engine" with Medium intensity]

"See the Timeline? Each step shows exactly how the code changed."
```

**Minute 2: Key Features**
```
Script:
"The number '10' became a complex expression. That's Number Encoding.

The addition turned into XOR, AND, multiply. That's Instruction Substitution.

[Scroll to Transformation Summary]

Every pass is documented. Every explanation is AI-generated but validated.

[Click Lingo validation badge]

Lingo.dev enforces terminology and structure. If validation fails, explanations are blocked.

[Switch to Researcher mode]

Researchers can define custom transformation rules.

[Show custom rule editor]

Create your own mutation patterns. Save configurations. Track rule hits.

This is Chaos Lab: making compiler transformations understandable."
```

### Use Cases

#### Educational (Student Mode)

**Scenario:** Computer Science student learning compiler design.

**Workflow:**
1. Select **Loops** example
2. Read **Learning Narrative** to understand pipeline
3. Click **Run Lab Engine** (Medium intensity)
4. Navigate **Timeline** to see each transformation
5. Read **Explanations** for each pass
6. Verify **Semantic Preservation** (output matches original)
7. Try different intensity levels

**Learning Outcomes:**
- Understand IR-level representation
- See how transformations preserve semantics
- Learn obfuscation techniques
- Grasp validation importance

#### Research (Researcher Mode)

**Scenario:** PhD student studying program obfuscation effectiveness.

**Workflow:**
1. Switch to **Researcher Mode**
2. Open **Chaos Orchestration** tab
3. Define custom substitution rule:
   ```
   Source: MUL
   Target: ADD, ADD, SUB, ADD
   ```
4. Disable standard passes except substitution
5. Run on **Obfuscation Demo** example
6. Export IR snapshots for analysis
7. Save configuration as "Multiplication Study"

**Research Outputs:**
- Custom transformation patterns
- Hit frequency metrics
- IR complexity measurements
- Semantic preservation verification

---

## Future Roadmap

### Planned Features

#### Phase 1: Enhanced Visualization
- [ ] 3D IR graph rendering (Three.js)
- [ ] Animated transformation transitions
- [ ] Control flow graph visualization
- [ ] Data dependency highlighting

#### Phase 2: Advanced Transformations
- [ ] Dead code insertion
- [ ] Variable live-range splitting
- [ ] Register allocation simulation
- [ ] SSA form conversion

#### Phase 3: Multi-Language Support
- [ ] JavaScript IR backend
- [ ] Python bytecode target
- [ ] LLVM IR export
- [ ] WebAssembly compilation

#### Phase 4: Collaboration
- [ ] Cloud preset sharing
- [ ] Transformation marketplace
- [ ] Real-time collaborative editing
- [ ] GitHub integration

#### Phase 5: Analysis Tools
- [ ] Complexity metrics dashboard
- [ ] Deobfuscation hints
- [ ] Pattern recognition
- [ ] Transformation efficiency scoring

### Technical Debt

- [ ] Reduce bundle size (code splitting)
- [ ] Implement Progressive Web App (PWA)
- [ ] Add TypeScript type definitions
- [ ] Optimize IR execution engine
- [ ] Comprehensive error boundaries

### Community

- [ ] Open source contribution guide
- [ ] Video tutorial series
- [ ] Research paper publication
- [ ] Academic partnerships
- [ ] Hackathon challenges

---

## Appendix

### Glossary

**AST (Abstract Syntax Tree)**: Tree representation of source code structure.

**IR (Intermediate Representation)**: Platform-independent code between source and machine code.

**Chaos Engine**: Core transformation system applying obfuscation passes.

**Semantic Preservation**: Guarantee that transformed code behaves identically to original.

**Opaque Predicate**: Condition whose outcome is known but hard to determine statically.

**Budget System**: Resource limits preventing excessive transformation complexity.

**Lingo.dev**: Validation authority enforcing diagnostic terminology and structure.

**MCP (Model Context Provider)**: AI explanation layer (untrusted until validated).

**Pass**: Single transformation stage in the compiler pipeline.

### File Structure Reference

```
chaos-COMPILER/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ compiler/
â”‚   â”‚   â”œâ”€â”€ lexer.js               # Tokenization
â”‚   â”‚   â”œâ”€â”€ parser.js              # AST generation
â”‚   â”‚   â”œâ”€â”€ ir.js                  # IR gen/transformation/execution
â”‚   â”‚   â”œâ”€â”€ codegen.js             # Assembly output
â”‚   â”‚   â”œâ”€â”€ diagnostics.js         # Diagnostic emission
â”‚   â”‚   â”œâ”€â”€ lingo.js               # Lingo validation
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚       â”œâ”€â”€ lexer.test.js      # Lexer tests
â”‚   â”‚       â”œâ”€â”€ parser.test.js     # Parser tests
â”‚   â”‚       â”œâ”€â”€ ir.test.js         # IR & chaos tests
â”‚   â”‚       â””â”€â”€ lingo.test.js      # Validation tests
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ App.jsx                # Root component
â”‚   â”‚   â”œâ”€â”€ EditorPanel.jsx        # Code editor
â”‚   â”‚   â”œâ”€â”€ IRDiffView.jsx         # Transformation timeline
â”‚   â”‚   â”œâ”€â”€ LingoPanel.jsx         # Validation & explanations
â”‚   â”‚   â”œâ”€â”€ ChaosConfig.jsx        # Orchestration controls
â”‚   â”‚   â”œâ”€â”€ ExampleLibrary.jsx     # 4-category examples
â”‚   â”‚   â”œâ”€â”€ LearningNarrative.jsx  # Pipeline stages
â”‚   â”‚   â”œâ”€â”€ TransformationSummary.jsx  # Pass checklist
â”‚   â”‚   â”œâ”€â”€ IntroOverlay.jsx       # First-run experience
â”‚   â”‚   â”œâ”€â”€ PipelineTab.jsx        # Architecture view
â”‚   â”‚   â””â”€â”€ DiagnosticsViewer.jsx  # Diagnostic list
â”‚   â”œâ”€â”€ main.jsx                   # React entry point
â”‚   â””â”€â”€ index.css                  # Global styles
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ logo.png
â”‚   â””â”€â”€ screenshots/
â”œâ”€â”€ reference-implementations/     # C reference code
â”œâ”€â”€ examples/                      # Demo programs
â”œâ”€â”€ package.json                   # Dependencies
â”œâ”€â”€ vite.config.js                 # Build config
â”œâ”€â”€ vitest.config.js               # Test config
â”œâ”€â”€ tailwind.config.js             # Styling config
â”œâ”€â”€ README.md                      # Quick start
â”œâ”€â”€ TESTING.md                     # Test documentation
â”œâ”€â”€ CHANGELOG.md                   # Version history
â”œâ”€â”€ HACKATHON.md                   # Demo guide
â””â”€â”€ TECHNICAL-DOCUMENTATION.md     # This file
```

### API Reference

#### Lexer API
```javascript
import { Lexer, TokenType } from './compiler/lexer';

const lexer = new Lexer(sourceCode);
const tokens = lexer.tokenize();
// Returns: Token[] = [{ type: TokenType, value: string, line: number }]
```

#### Parser API
```javascript
import { Parser } from './compiler/parser';

const parser = new Parser(tokens);
const ast = parser.parse();
// Returns: AST = { type: 'Program', body: Statement[] }
```

#### IR API
```javascript
import { generateIR, applyChaos, executeIR } from './compiler/ir';

// Generate IR from AST
const ir = generateIR(ast);

// Apply transformations
const { ir: transformedIR, snapshots, ruleHits } = applyChaos(
    ir,                    // Original IR
    'medium',              // Intensity: 'low' | 'medium' | 'high'
    12345,                 // Seed (optional, for determinism)
    chaosConfig            // Configuration (optional)
);

// Execute IR
const result = executeIR(ir, initialState, stdoutArray);
// Returns: number (return value)
```

#### Lingo API
```javascript
import { LingoCompiler } from './compiler/lingo';

// Validate diagnostics
const report = LingoCompiler.generateReport(diagnostics);
// Returns: { valid: boolean, errors: string[], warnings: string[], ... }

// Inject test failure
const testDiags = LingoCompiler.injectTestFailure(diags, 'MISSING_SEVERITY');
```

#### Diagnostics API
```javascript
import { diagnostics } from './compiler/diagnostics';

// Emit diagnostic
diagnostics.emit(
    'CHAOS_NUM_ENCODING',           // ID
    'chaos.data.encoding',          // Context
    'info',                         // Severity
    { original: 5, encoding: 't1' } // Params
);

// Retrieve all
const allDiags = diagnostics.getDiagnostics();

// Clear
diagnostics.clear();
```

### Configuration Examples

#### Chaos Config Structure
```javascript
const chaosConfig = {
    passes: {
        numberEncoding: true,    // Enable number encoding
        substitution: false,     // Disable substitution
        opaquePredicates: true,  // Enable opaque predicates
        flattening: false        // Disable flattening
    },
    customRules: [
        {
            id: 123456,
            source: 'ADD',
            target: 'XOR, AND, MUL, ADD'
        },
        {
            id: 123457,
            source: 'MUL',
            target: 'ADD, ADD, ADD'
        }
    ]
};
```

#### Demo Presets
```javascript
// Arithmetic-focused obfuscation
const arithmeticChaos = {
    passes: {
        numberEncoding: true,
        substitution: true,
        opaquePredicates: false,
        flattening: false
    },
    customRules: [
        { id: 1, source: 'ADD', target: 'XOR, AND, MUL' },
        { id: 2, source: 'SUB', target: 'ADD, NEG' }
    ]
};

// Control flow-focused obfuscation
const controlFlowChaos = {
    passes: {
        numberEncoding: false,
        substitution: false,
        opaquePredicates: true,
        flattening: true
    },
    customRules: []
};

// Maximum obfuscation
const heavyObfuscation = {
    passes: {
        numberEncoding: true,
        substitution: true,
        opaquePredicates: true,
        flattening: true
    },
    customRules: [
        { id: 3, source: 'ADD', target: 'XOR, AND, MUL, ADD' },
        { id: 4, source: 'MUL', target: 'ADD, ADD, ADD' }
    ]
};
```

---

## Conclusion

Chaos Lab represents a paradigm shift in compiler education: making the invisible visible, the complex understandable, and the unverified trustworthy. By combining real-time visualization, AI-generated explanations, and rigorous validation, it creates a unique learning environment for students and researchers.

The dual-mode system ensures accessibility for beginners while providing depth for experts. The validation-gated architecture establishes a new standard for trustworthy AI-assisted learning tools.

Whether you're a student learning compiler fundamentals, a researcher studying obfuscation techniques, or an educator teaching program transformation, Chaos Lab provides the transparency and control needed for effective learning and experimentation.

**Chaos Lab: Making compiler transformations visible, explainable, and verifiable.**

---

**Document Version:** 1.0.0  
**Last Updated:** February 1, 2026  
**Maintained By:** Chaos Lab Development Team  
**License:** MIT
